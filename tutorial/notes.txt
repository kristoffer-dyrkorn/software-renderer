
1. basic rasterizer

setup

we set indices in constructor - and have a separate array for vertices. (so they can be modified without impacting the structure of the triangle. will return to that later.)

note backface culling.
note bounding box
note integer-only operations.

note the edge functions, we compare against >= 0. (what to do with those ON edge? will return to that later.)

note lots of explicit calculations. full recalcuations for each pixel.


2. moar triangles, moar problems

low-resolution setup so we can better see what's going on.

so: what to do with those ON edge? we get overlaps. steals performance and leads to visual errors (result depends on the sequence we draw triangles in)

why are we subtracting 1? and not some other number? it is just a tie breaker for the case that two different triangles have pixels that lie exactly ON the edge. the edge tests uses comparison with 0 - so adjusting by 1 is the least change that will change the test outcome. 

3. animation

set up an animation where the triangle rotates, we use requestAnimationFrame.

put the basis coordinates of the vertices centered in origo, then calculate a new set of rotated vertices, and place them onto the middle of the screen.

note although the vertices rotate, but the triangle edge data (the triangle structure) remains the same. this is the reason for the separation between the constructor (set up static data for the triangle) and draw method (set up dynamic data spesific for this draw call).

note the unsmooth rotation - we send integer coordinates to the rasterizer, and this makes the triangle jump. this can be improved!

4a. let's go continuous!

start by letting the rasterizer accept floating-point coordinates

expand the bounding box out to integer coordinates that lie outside the input

also, we need to support continuous coordinates in the edge tests themself. that means we no longer consider pixels to have integer coordinates, but to lie on continuous axes, with the center of a pixel set to integer coordinate + 0.5. thus the edge function inside the bounding box needs to be evaluated at x + 0.5 and y + 0.5. (the + 0.5 is just a choice/convention, we here have choosen to let the left edge of the first pixel be x=0.)

look at the artifacts (the gap between the triangles)! the fill rule is right and we use floating points for extra precision. what is wrong?

4b.

the rasterizer now runs on floating-point coordinates. unfortunately, floating-point calculations are not precise, and slight rounding errors (in the edge test, for example) might lead to visual artifacts - missed, or overdrawn, pixels. also, some floating-point operations take longer time than their corresponding integer versions.

what to do? make a hybrid. we multiply all input by a fixed number, and round the result afterwards. this effectively means to subdivide the range after the comma (0..1) into a small set of values. (ie to quantize the number.) this hybrid number representaion is called fixed-point representation. it reduces precision a bit, but as long as we multiply by a suitably large number we retain enough precision to avoid visible artifacts. in sense, we snap coordiantes to a grid inside each pixel. so this is called subpixel precision.

the number we choose to multiply by is some number 2^n. that means we can get back to normal numbers - by bit-shifting n positions to the right. 

so, we 1) keep the smooth movements, 2) increase precision and 3) avoid performance hit from floating point numbers

which number 2^n is right? a large number would be nice, but we cannot use too many - we would like to use 32-bit (signed) integer for storage, thus the total amout of bits for the integer and decimal part is 31. if we assume the x and y screen coordinates are in the range 0..2048, the integer parts would consume 11 bits. however, when we calculate the determinant we multiply two fixed-point numbers, needing support for integers occupying up to 22 bits. under this assumption the maximum number of bits to allocate for sub-pixel accuracy is 8.

normally, there are few noticeable improvements when you increase allocation beyond 4 bits. and that's also the GPU (hardware) implementation standard. so we have chosen that here. 4 bits means we multiply by 16. this means we have some extra headroom for calculations on fixed-point numbers as well.

but - looking at the code now we do a lot of operations per pixel. we need to optimize.
we should rephrase our calculations by moving work up front (once per draw command) so there is less to do in the tight loop (once per pixel). from a quick profiling session we now seem to spend a lot of time calculating determinants and allocating memory.

on my machine, drawing this single triangle takes about 4.5 ms. we can go faster than that.

5. let's go incremental!

convert input to fixed point coords
setup up determinant calculation to happen at top left pix in bounding box
keep the w value for left side of bbox
find dwdx and dwdy

loop inside bbox
- update wLeft with dwdy
- evaluate w
- update w with dwdx (the sub is just convention, dep on sub sequence, wanted code to look like as for dx)
- update w with dwdy

note eval can now be done simpler as we are using 32-bit ints.

triangle drawing now takes 0.29 ms, 8% of the previous version - basically a 10x speedup.

but....we have a bug.

6.

it turns out - when we calculate things incrementally, it is extremely important to start at the right place.
(it is of course also important to make sure each incremental step is right - else errors will accumulate.)

when calculating the bounding box around the triangle we have so far (since we started using floating point coordinates for triangle vertices) just truncated the values. these values are input to the edge function evaluation at the first point - which all incremental calculations rely on.

we need to round those coordinates instead.


and with that, we have built a correct and efficient triangle rasteizer.



---

https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/rasterization-practical-implementation

https://gist.github.com/rygorous/9b793cd21d876da928bf4c7f3e625908

https://gist.github.com/rygorous/2486101